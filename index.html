<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Grid Converter</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 50px auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #fff;
        }
        h1 {
            text-align: center;
            color: #6aaa64;
        }
        .input-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        input[type="text"] {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            border: 2px solid #444;
            border-radius: 4px;
            box-sizing: border-box;
            background: #1a1a1a;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #6aaa64;
        }
        .result {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            min-height: 150px;
            overflow-x: auto;
            position: relative;
        }
        .score {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #6aaa64;
        }
        .pixel-grid {
            display: inline-block;
            line-height: 1;
            font-size: 12px;
            white-space: pre;
            font-family: 'Courier New', monospace;
        }
        .pixel {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin: 0;
        }
        .green {
            background-color: #6aaa64;
        }
        .yellow {
            background-color: #c9b458;
        }
        .instructions {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #6aaa64;
        }
        .instructions h3 {
            margin-top: 0;
            color: #6aaa64;
        }
        .instructions ul {
            margin: 10px 0;
        }
        .grid-row {
            white-space: nowrap;
            line-height: 14px;
        }
        .copy-button {
            background: #6aaa64;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            transition: background 0.2s;
        }
        .copy-button:hover {
            background: #5a9a54;
        }
        .copy-button:active {
            background: #4a8a44;
        }
        .copy-button.copied {
            background: #c9b458;
        }
        .shareable-preview {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            border: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>üéÆ Wordle Pixel Art Converter</h1>
    
    <div class="instructions">
        <h3>How to use:</h3>
        <ul>
            <li><strong>Letter Mode:</strong> Type text - UPPERCASE = Primary color (üü©), lowercase = Secondary color (üü®)</li>
            <li><strong>Custom Mode:</strong> Click blocks to cycle through colors and build your own Wordle grid!</li>
            <li><strong>3x3 Size:</strong> Fewer emojis = better chance of matte appearance in Discord</li>
            <li><strong>5x5 Size:</strong> More detailed letters but may appear glossy in Discord</li>
            <li><strong>3D Mode:</strong> Adds side shadows for depth! (Letter mode only)</li>
            <li><strong>üé® Customize Colors:</strong> Pick any color for letters and shadows!</li>
        </ul>
    </div>

    <div class="input-section">
        <input 
            type="text" 
            id="textInput" 
            placeholder="Type something like: HI or HELLO WORLD (spaces = line breaks)"
            value="HI"
            maxlength="50"
        >
    </div>

    <div class="result" id="result">
        <!-- Grid will appear here -->
    </div>

    <script>
        const letterPatterns = {
            'A': ['01110','10001','11111','10001','10001'],
            'B': ['11110','10001','11110','10001','11110'],
            'C': ['01110','10001','10000','10001','01110'],
            'D': ['11110','10001','10001','10001','11110'],
            'E': ['11111','10000','11110','10000','11111'],
            'F': ['11111','10000','11110','10000','10000'],
            'G': ['01110','10000','10011','10001','01110'],
            'H': ['10001','10001','11111','10001','10001'],
            'I': ['11111','00100','00100','00100','11111'],
            'J': ['11111','00010','00010','10010','01100'],
            'K': ['10001','10010','11100','10010','10001'],
            'L': ['10000','10000','10000','10000','11111'],
            'M': ['10001','11011','10101','10001','10001'],
            'N': ['10001','11001','10101','10011','10001'],
            'O': ['01110','10001','10001','10001','01110'],
            'P': ['11110','10001','11110','10000','10000'],
            'Q': ['01110','10001','10001','10101','01111'],
            'R': ['11110','10001','11110','10010','10001'],
            'S': ['01111','10000','01110','00001','11110'],
            'T': ['11111','00100','00100','00100','00100'],
            'U': ['10001','10001','10001','10001','01110'],
            'V': ['10001','10001','10001','01010','00100'],
            'W': ['10001','10001','10101','11011','10001'],
            'X': ['10001','01010','00100','01010','10001'],
            'Y': ['10001','01010','00100','00100','00100'],
            'Z': ['11111','00010','00100','01000','11111'],
            ' ': ['00000','00000','00000','00000','00000']
        };

        const letterPatterns3x3 = {
            'A': ['010','111','101'],
            'B': ['110','110','110'],
            'C': ['110','100','110'],
            'D': ['110','101','110'],
            'E': ['111','110','111'],
            'F': ['111','110','100'],
            'G': ['110','101','111'],
            'H': ['101','111','101'],
            'I': ['111','010','111'],
            'J': ['111','001','110'],
            'K': ['101','110','101'],
            'L': ['100','100','111'],
            'M': ['101','111','101'],
            'N': ['110','101','101'],
            'O': ['010','101','010'],
            'P': ['110','110','100'],
            'Q': ['010','101','011'],
            'R': ['110','110','101'],
            'S': ['011','010','110'],
            'T': ['111','010','010'],
            'U': ['101','101','111'],
            'V': ['101','101','010'],
            'W': ['101','111','101'],
            'X': ['101','010','101'],
            'Y': ['101','010','010'],
            'Z': ['111','010','111'],
            ' ': ['000','000','000']
        };

        let currentShareableText = '';
        let darkMode = false;
        let use3x3 = false;
        let use3D = false;
        let customMode = false;
        
        // Custom mode state
        let customRows = 6; // Default 6 rows like Wordle
        let customGrid = []; // Will store the custom grid state
        
        // Default colors
        let greenColor = 'üü©';
        let yellowColor = 'üü®';
        let greenShadow = 'üü´';
        let yellowShadow = 'üüß';
        
        // Available color options (emojis)
        const colorOptions = {
            'üü©': 'Green',
            'üü®': 'Yellow', 
            'üüß': 'Orange',
            'üü•': 'Red',
            'üü¶': 'Blue',
            'üü™': 'Purple',
            'üü´': 'Brown',
            '‚¨õ': 'Black',
            '‚¨ú': 'White'
        };
        
        // Calculate current Wordle number
        // Wordle 1,665 was on January 9, 2026
        function getWordleNumber() {
            const wordleStart = new Date('2026-01-09'); // Wordle 1,665
            const wordleStartNumber = 1665;
            const today = new Date();
            
            // Calculate days difference
            const diffTime = today - wordleStart;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            return wordleStartNumber + diffDays;
        }
        
        // Initialize custom grid
        function initCustomGrid() {
            customGrid = [];
            const emptySquare = darkMode ? '‚¨õ' : '‚¨ú';
            for (let i = 0; i < customRows; i++) {
                customGrid.push([emptySquare, emptySquare, emptySquare, emptySquare, emptySquare]);
            }
        }
        
        // Cycle block color in custom mode
        function cycleBlockColor(row, col) {
            const emptySquare = darkMode ? '‚¨õ' : '‚¨ú';
            const current = customGrid[row][col];
            
            // Cycle: empty -> green -> yellow -> empty
            if (current === emptySquare) {
                customGrid[row][col] = greenColor;
            } else if (current === greenColor) {
                customGrid[row][col] = yellowColor;
            } else {
                customGrid[row][col] = emptySquare;
            }
            
            renderCustomMode();
        }
        
        // Render custom mode UI
        function renderCustomMode() {
            const emptySquare = darkMode ? '‚¨õ' : '‚¨ú';
            const wordleNum = getWordleNumber().toLocaleString('en-US');
            
            const modeIcon = darkMode ? '‚òÄÔ∏è' : 'üåô';
            const modeText = darkMode ? 'Light Mode' : 'Dark Mode';
            
            let html = '<div class="score">Custom Wordle Grid Builder</div>';
            
            html += '<div style="margin: 15px 0;">';
            html += '<button class="copy-button" onclick="toggleCustomMode()">‚Üê Back to Letter Mode</button>';
            html += `<button class="copy-button" onclick="toggleDarkMode()" style="margin-left: 10px;">${modeIcon} ${modeText}</button>`;
            html += '</div>';
            
            html += '<div style="margin: 20px 0;">';
            html += '<label style="margin-right: 10px;">Number of rows:</label>';
            html += '<input type="number" id="customRowsInput" min="1" max="12" value="' + customRows + '" onchange="updateCustomRows(this.value)" style="width: 60px; padding: 5px; background: #2a2a2a; color: white; border: 1px solid #444; border-radius: 4px;">';
            html += '</div>';
            
            html += '<div style="margin: 20px 0;">';
            
            // Render clickable grid
            for (let row = 0; row < customRows; row++) {
                html += '<div style="margin: 5px 0;">';
                for (let col = 0; col < 5; col++) {
                    const block = customGrid[row][col];
                    html += `<button onclick="cycleBlockColor(${row}, ${col})" style="font-size: 32px; width: 50px; height: 50px; margin: 2px; border: 2px solid #444; background: #1a1a1a; cursor: pointer; border-radius: 4px;">${block}</button>`;
                }
                html += '</div>';
            }
            html += '</div>';
            
            // Add copy button
            html += '<div style="margin-top: 15px;">';
            html += '<button class="copy-button" onclick="copyToClipboard()">üìã Copy to Clipboard</button>';
            html += '</div>';
            
            // Generate shareable text
            currentShareableText = `Wordle ${wordleNum} ${customRows}/6\n\n`;
            for (let row = 0; row < customRows; row++) {
                currentShareableText += customGrid[row].join('') + '\n';
            }
            
            // Add preview
            html += `<div class="shareable-preview">${currentShareableText}</div>`;
            
            document.getElementById('result').innerHTML = html;
        }

        function createWordleGrid(text) {
            if (!text) return '<p style="color: #999;">Type something to see the pixel art...</p>';
            
            // If in custom mode, render custom grid instead
            if (customMode) {
                renderCustomMode();
                return;
            }
            
            // Split by spaces to create separate words/lines
            const words = text.split(' ').filter(w => w.length > 0);
            
            const totalLetters = text.replace(/[^a-zA-Z]/g, '').length;
            const correctLetters = (text.match(/[A-Z]/g) || []).length;
            const presentLetters = (text.match(/[a-z]/g) || []).length;
            const score = correctLetters * 10 + presentLetters * 5;
            
            // Use proper block characters for matte/flat appearance
            const emptySquare = darkMode ? '‚¨õ' : '‚¨ú';
            
            // Select pattern set based on toggle
            const patterns = use3x3 ? letterPatterns3x3 : letterPatterns;
            const gridSize = use3x3 ? 3 : 5;
            
            let html = `<div class="score">Wordle ${text.replace(/ /g, '').length}/${totalLetters} (${correctLetters} correct, ${presentLetters} present)</div>`;
            html += '<div class="pixel-grid">';
            
            // Get current Wordle number and format with comma
            const wordleNum = getWordleNumber().toLocaleString('en-US');
            
            // Create shareable text header
            currentShareableText = `Wordle ${wordleNum}\n\n`;
            
            // Track maximum width for padding
            let maxWidth = 0;
            let allEmojiGrids = [];
            
            // Process each word separately
            for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
                const word = words[wordIndex];
                const chars = word.toUpperCase().split('');
                const grid = Array(gridSize).fill('').map(() => '');
                let emojiGrid = Array(gridSize).fill('').map(() => []);
                
                for (let i = 0; i < chars.length; i++) {
                    const char = chars[i];
                    const originalChar = word[i];
                    const isUpperCase = originalChar >= 'A' && originalChar <= 'Z';
                    const pattern = patterns[char] || patterns[' '];
                    const colorClass = isUpperCase ? 'green' : 'yellow';
                    const emoji = isUpperCase ? greenColor : yellowColor;
                    
                    if (i > 0) {
                        for (let row = 0; row < gridSize; row++) {
                            grid[row] += '<span class="pixel"></span>'; // Space between letters
                            emojiGrid[row].push(emptySquare);
                        }
                    }
                    
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < pattern[row].length; col++) {
                            if (pattern[row][col] === '1') {
                                grid[row] += `<span class="pixel ${colorClass}"></span>`;
                                emojiGrid[row].push(emoji);
                            } else {
                                grid[row] += '<span class="pixel"></span>';
                                emojiGrid[row].push(emptySquare);
                            }
                        }
                    }
                }
                
                // Add 3D side shadows if enabled (without shifting or distorting letters)
                if (use3D) {
                    const iso3DGrid = [];
                    
                    for (let row = 0; row < gridSize; row++) {
                        const newRow = [];
                        
                        for (let col = 0; col < emojiGrid[row].length; col++) {
                            const currentBlock = emojiGrid[row][col];
                            const nextBlock = col < emojiGrid[row].length - 1 ? emojiGrid[row][col + 1] : null;
                            
                            // Add the current block
                            newRow.push(currentBlock);
                            
                            // Add shadow to the right of colored blocks, but only if next position is empty
                            if ((currentBlock === greenColor || currentBlock === yellowColor)) {
                                // Check if next block is empty (we can add shadow)
                                if (nextBlock === emptySquare) {
                                    const shadowColor = currentBlock === greenColor ? greenShadow : yellowShadow;
                                    newRow.push(shadowColor);
                                    col++; // Skip the next position since we're replacing it with shadow
                                }
                            }
                        }
                        
                        // Add shadow on the far right if the last block in this row is colored
                        const lastBlock = emojiGrid[row][emojiGrid[row].length - 1];
                        if (lastBlock === greenColor || lastBlock === yellowColor) {
                            const shadowColor = lastBlock === greenColor ? greenShadow : yellowShadow;
                            newRow.push(shadowColor);
                        }
                        
                        iso3DGrid.push(newRow);
                    }
                    
                    emojiGrid = iso3DGrid;
                } else {
                    // No modifications for 2D mode
                }
                
                // Track max width
                const currentWidth = Math.max(...emojiGrid.map(row => row.length));
                maxWidth = Math.max(maxWidth, currentWidth);
                
                allEmojiGrids.push({
                    emojiGrid,
                    grid,
                    gridSize
                });
            }
            
            // Now pad all grids to maxWidth and build output
            for (let wordIndex = 0; wordIndex < allEmojiGrids.length; wordIndex++) {
                const { emojiGrid, grid, gridSize } = allEmojiGrids[wordIndex];
                
                // Pad each row to maxWidth
                const paddedEmojiGrid = emojiGrid.map(row => {
                    const currentWidth = row.length;
                    const padding = Array(maxWidth - currentWidth).fill(emptySquare);
                    return [...row, ...padding];
                });
                
                // Add this word's grid to HTML
                for (let row = 0; row < gridSize; row++) {
                    html += `<div class="grid-row">${grid[row]}</div>`;
                }
                
                // Add this word's emoji grid to shareable text
                currentShareableText += paddedEmojiGrid.map(row => row.join('')).join('\n');
                
                // Add line break between words if not the last word
                if (wordIndex < allEmojiGrids.length - 1) {
                    html += '<div style="height: 10px;"></div>'; // Visual spacing
                    currentShareableText += '\n\n';
                }
            }
            
            html += '</div>';
            
            const modeIcon = darkMode ? '‚òÄÔ∏è' : 'üåô';
            const modeText = darkMode ? 'Light Mode' : 'Dark Mode';
            const sizeIcon = use3x3 ? 'üîç' : 'üîé';
            const sizeText = use3x3 ? '5x5 Size' : '3x3 Size';
            const depthIcon = use3D ? 'üì¶' : 'üé®';
            const depthText = use3D ? '2D Mode' : '3D Mode';
            const customIcon = customMode ? '‚úèÔ∏è' : 'üéØ';
            const customText = customMode ? 'Letter Mode' : 'Custom Mode';
            
            html += '<div style="margin-top: 15px;">';
            html += '<button class="copy-button" onclick="copyToClipboard()">üìã Copy to Clipboard</button>';
            html += `<button class="copy-button" onclick="toggleCustomMode()" style="margin-left: 10px;">${customIcon} ${customText}</button>`;
            html += `<button class="copy-button" onclick="toggleDarkMode()" style="margin-left: 10px;">${modeIcon} ${modeText}</button>`;
            html += `<button class="copy-button" onclick="toggleSize()" style="margin-left: 10px;">${sizeIcon} ${sizeText}</button>`;
            html += `<button class="copy-button" onclick="toggle3D()" style="margin-left: 10px;">${depthIcon} ${depthText}</button>`;
            html += '</div>';
            
            html += '<div style="margin-top: 15px; padding: 15px; background: #1a1a1a; border-radius: 8px;">';
            html += '<div style="margin-bottom: 10px; color: #6aaa64; font-weight: bold;">üé® Color Customization</div>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 10px;">';
            html += '<div style="flex: 1; min-width: 200px;">';
            html += '<label style="display: block; margin-bottom: 5px; font-size: 14px;">UPPERCASE Color: ${greenColor}</label>';
            html += '<select id="greenPicker" onchange="updateGreenColor(this.value)" style="width: 100%; padding: 8px; background: #2a2a2a; color: white; border: 1px solid #444; border-radius: 4px; font-size: 16px;">';
            Object.entries(colorOptions).forEach(([emoji, name]) => {
                const selected = emoji === greenColor ? 'selected' : '';
                html += `<option value="${emoji}" ${selected}>${emoji} ${name}</option>`;
            });
            html += '</select>';
            html += '</div>';
            html += '<div style="flex: 1; min-width: 200px;">';
            html += '<label style="display: block; margin-bottom: 5px; font-size: 14px;">UPPERCASE Shadow: ${greenShadow}</label>';
            html += '<select id="greenShadowPicker" onchange="updateGreenShadow(this.value)" style="width: 100%; padding: 8px; background: #2a2a2a; color: white; border: 1px solid #444; border-radius: 4px; font-size: 16px;">';
            Object.entries(colorOptions).forEach(([emoji, name]) => {
                const selected = emoji === greenShadow ? 'selected' : '';
                html += `<option value="${emoji}" ${selected}>${emoji} ${name}</option>`;
            });
            html += '</select>';
            html += '</div>';
            html += '<div style="flex: 1; min-width: 200px;">';
            html += '<label style="display: block; margin-bottom: 5px; font-size: 14px;">lowercase Color: ${yellowColor}</label>';
            html += '<select id="yellowPicker" onchange="updateYellowColor(this.value)" style="width: 100%; padding: 8px; background: #2a2a2a; color: white; border: 1px solid #444; border-radius: 4px; font-size: 16px;">';
            Object.entries(colorOptions).forEach(([emoji, name]) => {
                const selected = emoji === yellowColor ? 'selected' : '';
                html += `<option value="${emoji}" ${selected}>${emoji} ${name}</option>`;
            });
            html += '</select>';
            html += '</div>';
            html += '<div style="flex: 1; min-width: 200px;">';
            html += '<label style="display: block; margin-bottom: 5px; font-size: 14px;">lowercase Shadow: ${yellowShadow}</label>';
            html += '<select id="yellowShadowPicker" onchange="updateYellowShadow(this.value)" style="width: 100%; padding: 8px; background: #2a2a2a; color: white; border: 1px solid #444; border-radius: 4px; font-size: 16px;">';
            Object.entries(colorOptions).forEach(([emoji, name]) => {
                const selected = emoji === yellowShadow ? 'selected' : '';
                html += `<option value="${emoji}" ${selected}>${emoji} ${name}</option>`;
            });
            html += '</select>';
            html += '</div>';
            html += '</div>';
            html += '</div>';
            html += `<div class="shareable-preview">${currentShareableText}</div>`;
            
            return html;
        }

        function toggleDarkMode() {
            darkMode = !darkMode;
            if (customMode) {
                // Update empty squares in custom grid when switching dark mode
                const oldEmpty = !darkMode ? '‚¨õ' : '‚¨ú';
                const newEmpty = darkMode ? '‚¨õ' : '‚¨ú';
                for (let row = 0; row < customRows; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (customGrid[row][col] === oldEmpty) {
                            customGrid[row][col] = newEmpty;
                        }
                    }
                }
                renderCustomMode();
            } else {
                updateGrid();
            }
        }

        function toggleSize() {
            use3x3 = !use3x3;
            updateGrid();
        }

        function toggle3D() {
            use3D = !use3D;
            updateGrid();
        }
        
        function toggleCustomMode() {
            customMode = !customMode;
            if (customMode) {
                initCustomGrid();
                renderCustomMode();
            } else {
                updateGrid();
            }
        }
        
        function updateCustomRows(value) {
            customRows = parseInt(value) || 6;
            initCustomGrid();
            renderCustomMode();
        }
        
        function updateGreenColor(color) {
            greenColor = color;
            if (customMode) {
                // Update existing green blocks in custom grid
                for (let row = 0; row < customRows; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (customGrid[row][col] === 'üü©') {
                            customGrid[row][col] = greenColor;
                        }
                    }
                }
                renderCustomMode();
            } else {
                updateGrid();
            }
        }
        
        function updateGreenShadow(color) {
            greenShadow = color;
            if (!customMode) updateGrid();
        }
        
        function updateYellowColor(color) {
            yellowColor = color;
            if (customMode) {
                // Update existing yellow blocks in custom grid
                for (let row = 0; row < customRows; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (customGrid[row][col] === 'üü®') {
                            customGrid[row][col] = yellowColor;
                        }
                    }
                }
                renderCustomMode();
            } else {
                updateGrid();
            }
        }
        
        function updateYellowShadow(color) {
            yellowShadow = color;
            if (!customMode) updateGrid();
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(currentShareableText);
                const button = document.querySelector('.copy-button');
                const originalText = button.textContent;
                button.textContent = '‚úì Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            } catch (err) {
                alert('Failed to copy to clipboard. Please try again.');
            }
        }

        const input = document.getElementById('textInput');
        const result = document.getElementById('result');

        function updateGrid() {
            result.innerHTML = createWordleGrid(input.value);
        }

        input.addEventListener('input', updateGrid);
        updateGrid();

        // Make functions available globally
        window.copyToClipboard = copyToClipboard;
        window.toggleDarkMode = toggleDarkMode;
        window.toggleSize = toggleSize;
        window.toggle3D = toggle3D;
        window.toggleCustomMode = toggleCustomMode;
        window.updateCustomRows = updateCustomRows;
        window.cycleBlockColor = cycleBlockColor;
        window.updateGreenColor = updateGreenColor;
        window.updateGreenShadow = updateGreenShadow;
        window.updateYellowColor = updateYellowColor;
        window.updateYellowShadow = updateYellowShadow;
    </script>
</body>
</html>
